#include <SoftwareSerial.h>
#include <string.h>

SoftwareSerial edip240(10, 11); //RX, TX
/*
   given the display size 240x128 we would need quite a lot of ram 30720k (atmega328p has only 2k)
   given the phisical pixel size we will use 4 pixels to represent a cell,giving us a 60x32 world, which will require 1920k (still too much)
   given that one cell can have only two statest alive/dead (1/0) we can save the states of 8 cells in 1 byte requiring only 256bytes(8x32) of ram :)

*/
#define WORLD_X_MAX 60
#define WORLD_Y_MAX 32
#define DEBUG 0

uint8_t current_life[256] ={
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};


uint8_t next_life[256] = {0};


uint8_t count_neighbours(uint8_t cell_x, uint8_t cell_y) {

  int16_t neighbours, nx, x, ny, y;

  neighbours = cell_at(cell_x, cell_y, current_life, 2) ? -1 : 0;
  for ( x = -1; x <= 1; x++) {
    for (y = -1; y <= 1; y++) {
      nx = (WORLD_X_MAX + x + cell_x) % WORLD_X_MAX;
      ny = (WORLD_Y_MAX + y + cell_y) % WORLD_Y_MAX;
      if (cell_at(nx, ny, current_life, 2)) {
        neighbours++;
      }
    }
  }
  return neighbours;
}

void next_generation() {
  uint8_t x, y, neighbours, is_alive;

  //calculate next life
  for (x = 0; x < WORLD_X_MAX; x++) {
    for (y = 0; y < WORLD_Y_MAX; y++) {
      neighbours = count_neighbours(x, y);
      is_alive = cell_at(x, y, current_life, 2);
      if (neighbours < 2 && is_alive)
        cell_at(x, y, next_life, 0); //dead - under-population
      if (neighbours > 3 && is_alive)
        cell_at(x, y, next_life, 0); //dead - overcrowding
      if ((neighbours >= 2 && neighbours <= 3) && is_alive)
        cell_at(x, y, next_life, 1); //alive
      if (neighbours == 3 && !is_alive)
        cell_at(x, y, next_life, 1); //alive - reproduction
    }
  }
  //display next life
  edip240_send("#DL");
  for (x = 0; x < WORLD_X_MAX; x++) {
    for (y = 0; y < WORLD_Y_MAX; y++) {
      if (cell_at(x, y, current_life, 2))
        edip240_draw_cell(x * 4, y * 4, 1);
    }
  }
  //copy next live to current life
  memcpy(current_life,next_life,256);  
}




void setup() {
  //for debug
  Serial.begin(115200);
  //serial com for display
  edip240.begin(115200);


  Serial.print("neighbours count: ");
  Serial.println(count_neighbours(1, 1));

  //variables

  uint8_t idx = 0;

//  //random data
//  randomSeed(analogRead(0));
//  for (idx = 0; idx < 255; idx++)
//    current_life[idx] = (uint8_t)random(0,255);
}

void loop() {
  next_generation();
  delay(1000);
}





